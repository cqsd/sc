#!/usr/bin/env python3
# using this script to basically just catch results from scraper bookmarklets
# basically a bookmarklet is written to scrape shit in the browser
# this is just one way to cap the data...
# xhr request to localhost:9753/<data type>/<base64-encoded data>
# get the data back out by doing GET /_/<data type>
import codecs
import json
import os
import sys

from base64 import b64decode
from http.server import BaseHTTPRequestHandler, HTTPServer


state = {}


formatters = {
    '_default': lambda l: '\n'.join(l),
    'gh': lambda l: '\n'.join(s.strip() for s in set(l))
}


def make_handler(port):
    class Handler(BaseHTTPRequestHandler):
        def __init__(self, *args, **kwargs):
            self.host = os.uname().nodename  # supposedly doesn't work on windows
            self.port = port

            super(Handler, self).__init__(*args, **kwargs)

        def do_GET(self):
            # first char in path is /
            kind, resource = self.path[1:].split('/')
            print(f'kind: {kind}, resource: {resource}')
            if kind == '_':
                self.send_headers(
                    path=self.path,
                    content_type='text/plain',
                    response=200)
                self.end_headers()  # see base class

                # return either the requested resource or the whole state if
                # there's not entry for the resource
                requested = state.get(resource, state)
                formatter = formatters.get(resource, formatters['_default'])
                self.wfile.write(
                    codecs.encode(
                        formatter(requested),
                        'ascii')
                )
            else:
                self.send_headers(
                    path=self.path,
                    content_type='text/html',
                    response=200)
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()  # see base class
                data = b64decode(resource).decode('utf-8')

                print(f'Got data: {data}')

                if state.get(kind):
                    state[kind].append(data)
                else:
                    state[kind] = [data]
            print(state)

        def send_headers(self, path, content_type, response=200):
            self.send_response(response)
            self.send_header('Content-type', content_type)

    return Handler


def run_server_cmd(args):
    import socket

    port = args.port
    address = ('', port)

    try:
        httpd = HTTPServer(address, make_handler(port))
        sa = httpd.socket.getsockname()
        sys.stdout.write(
            'Serving HTTP on {} port {} (http://{}:{}/) ...\n'.format(*(sa * 2))
        )
        httpd.serve_forever()
    except socket.error:
        sys.stderr.write(
            'Error opening socket for port {}.\n'
            'You can pass a different port to the server as an argument.\n'
            ''.format(port)  # mfw ''.format
        )
    except KeyboardInterrupt:
        sys.stderr.write(
            '\nKeyboard interrupt received, exiting.'
            '\nCurrent state dump:\n'
        )
        sys.stdout.write(json.dumps(state, indent='  '))
    except Exception:
        sys.stderr.write(
            '\nLol, something broke.\n'
        )
        sys.exit(1)


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser('scrape', description='scraper catcher thing')
    parser.set_defaults(func=None)
    parser.add_argument('--port', '-p', help='port to run on', type=int, default=9753)

    subparsers = parser.add_subparsers(title='subcommands')

    run_subparser = subparsers.add_parser('run', help='Run the server')
    run_subparser.set_defaults(func=run_server_cmd)

    # TODO
    # retrieve_subparser = subparsers.add_parser('get', help='get shit thats been collected')
    # retrieve_subparser.set_defaults(func=run_server_cmd)

    args = parser.parse_args()

    if args.func:
        args.func(args)
    else:
        parser.print_usage()
