#!/bin/bash
### setup, search, edit, etc.

__SETUP_DIR=$__BASEDIR/setup

_meta_search() { ### search for a command
    __search_usage() {
        echo usage: search TERM
        exit 1
    }
    if [ $# -lt 1 ]; then
        __search_usage
    fi
    term=$1; shift
    echo matching commands:
    # -h hides file name
    # search all non-private function definitions in modules for matching command
    # name. note the second grep: __ (dunder) functions are for internal use
    grep -hior -e "^_.*${term}.*()" ${__BASEDIR}/modules \
        | grep -ve short_help -e __ \
        | sed -e 's/_/ /g' \
              -e 's/^ /  /g' \
              -e 's/()//g' # clean up the output a bit; this might be a bug
}

_meta_setup() { ### install/build deps (mostly unimplemented)
    __setup_usage() {
        echo usage: setup ITEM
        echo
        echo available items
        echo "  all - setup everything below"
        ls $__setup_usage | sed "s/^/  /g"
        exit 1
    }
    if [ $# -lt 1 ]; then
        __setup_usage
    fi
    name=$1; shift
    case $name in
        all)
            for d in $__SETUP_DIR; do
                __info setting up $d
                $d/setup
            done
            ;;
        *)
            if ! [ -f $__SETUP_DIR/$name/setup ]; then
                __error $name is not recognized as a setup item
                __setup_usage
            fi
            __info setting up $name
            $__SETUP_DIR/$name/setup
            ;;
    esac
}

_meta_edit() { ### edit source for a module
    if [ $# -ne 1 ]; then
        echo usage: edit MODULE
        echo
        echo available modules:
        echo $__BASEDIR/modules/* | xargs basename | sed 's/^/  /g'
        exit 1
    fi

    if [ $1 = 'base' ]; then
        $__EDITOR $__BASEDIR/base
    else
        module=$__BASEDIR/modules/$1
        if ! [ -f $module ]; then
            echo no module "$module"
        else
            $__EDITOR $module
        fi
    fi
}

_meta_show() { ### show source for a command
    if [ $# -ne 2 ]; then
        echo usage: show module subcommand
        exit 1
    fi

    module=$1
    subcommand=$2
    full_command=_${module}_${subcommand}
    # due to _where_ this gets sourced (ie, in ../base), the global namespace
    # is already polluted with all the function definitions
    declare -f $full_command  # | sed -e '1,2d;$d' # remove signature and braces
}

_meta_create-module() { ### create a new module
    if [ $# -ne 1 ]; then
        echo usage: new-module NAME
        exit 1
    fi

    name=$1
    if [ -f $__BASEDIR/modules/$name ]; then
        echo a module named $1 already exists
        exit 1
    fi

    template=$__BASEDIR/data/meta/module-template
    module=$__BASEDIR/modules/$name
    cat $template | sed "s/{{name}}/${name}/g" > $module
    _meta_edit $name
}

_meta_test-loggers() {
    __success ${1:-"test success ||||||||||||||||"}
    __info    ${1:-"test info    ||||||||||||||||"}
    __warn    ${1:-"test warn    ||||||||||||||||"}
    __error   ${1:-"test error   ||||||||||||||||"}
}
