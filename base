#!/bin/bash
# bash hax
# rui <rui@uwu.zone>

# Every file in ./modules/ gets sourced. Each file is a "module" That means
# everything's gonna be in this one top level namespace That means submodules
# can't easily import shit
#
# Every module should prefix all functions with an underscore, the module name,
# and an underscore. So a hello command in the example module would be defined
# as _example_hello()
#
# Every module should define a function named the module name. So the dns
# module defines a dns function. This is called as the subcommand help, so it
# should just echo usage info.
#
# Every module can optionally define a short help function,
# ${module}_short_help, which is called to generate the one-line usage hint in
# the top level usage text. Run this script with no arguments to see what I
# mean.
#
# ***If you can think of a non-ridiculous way to namespace the functions,
# please let me know.***

set -eo pipefail  # unsure if this is a good idea, but hasn't been annoying yet

__success() { echo -e "\033[32m[+] $@\033[0m"; }  # [+] green
__info()    { echo -e "\033[34m[+] $@\033[0m"; }  # [+] blue
__warn()    { echo -e "\033[33m[-] $@\033[0m"; }  # [-] yellow
__error()   { echo -e "\033[31m[!] $@\033[0m"; }  # [!] red

__remove_json_artifacts() { tr -d '[]",'; }

__requires() {
    for cmd in "$@"; do
        if ! command -v $cmd &>/dev/null; then
            echo "this command requires $cmd. please install $cmd"
            exit 1
        fi
    done
}

__requires_one_of() {
    for cmd in "$@"; do
        command -v $cmd &>/dev/null && echo $cmd && return
    done
    echo "this command requires one of $@" >&2
    exit 1
}

__BASEDIR=$(dirname "$(readlink "$0")")
__CONFIG_DIR=$__BASEDIR/config
__BIN_DIR=$__BASEDIR/bin
__DATA_DIR=$__BASEDIR/data

__EDITOR=${EDITOR:-vi}

MODULES=()
for file in ${__BASEDIR}/modules/*; do
    MODULE=$(basename $file)
    case $MODULE in
        _*)
            # skip anything that has a _ at the start of its filename
            continue
            ;;
        *)
            # "load" the module
            source $file
            # Every module should define a function with a name == the file
            # name. Additionally, each one can have a _${filename}_help()
            # function which will get displayed in top-level help.
            # It'll get called as help.
            MODULES+=($MODULE)
    esac
done

# return the length of the longest arg
max_length() {
    MAX_LENGTH=-1
    for s in $@; do
        # ${#var} => str length of ${var}
        if [ ${#s} -gt $MAX_LENGTH ]; then
            MAX_LENGTH=${#s}
        fi
    done
    echo $((MAX_LENGTH))  # dont think the math mode is necessary idc
}

print_helptext() {
    left_pad_length=$1
    name=$2
    helptext=$3
    printf "  %-${left_pad_length}s - %s\n" $name "${helptext:-no help found}"
}

# grep for top level docstring in a module
module_docstring() {
    module=$1
    {
        grep -o '^### .*$' $__BASEDIR/modules/$module \
            | sed -e 's/^###//g' \
                  -e 's/^ *//g'
    } || true
}

# grep for "public" function definitions in a module (includes docstrings)
function_definitions() {
    module=$1
    grep -hior -e "^_${module}_.*().*$" ${__BASEDIR}/modules/$module
}

function_name_from_definition() {
    grep -v '^__' \
        | sed -e 's/_/ /g' \
              -e 's/ *{.*//g' \
              -e 's/^ *//g' \
              -e 's/()//g' \
        | cut -d' ' -f2-
}

function_names() {
    function_definitions $1 | function_name_from_definition
}

# ngl this is pretty fuckin bad
function_docstring_from_definition() {
    {
        grep -o '### .*$' \
            | sed -e 's/^###//g' \
                  -e 's/^ *//g'
    } || true # for when grep finds nothing
}

# print function docstrings in a module. this relies on you (me) always
# defining functions a certain way. there's already a lot of that in this
# project, so I'll tolerate it, but it's obviously not great...
module_function_usage() {
    module=$1
    # doing the same grep a bunch of times is simpler to write than building
    # and managing arrays in bash (cuz i don't know how to use a bash hash and
    # i don't care rn)
    left_pad_length=$(max_length $(function_names $module))
    IFS=$'\n'
    for definition in $(function_definitions $module); do
        name=$(echo $definition | function_name_from_definition)
        docstring=$(echo $definition | function_docstring_from_definition)
        print_helptext $left_pad_length "$name" "$docstring"
    done
    unset IFS
}

usage() {
    echo "usage: $(basename $0) <category> [command]"
    echo
    echo "available categories are:"
    left_pad_length=$(max_length ${MODULES[@]})
    for module in ${MODULES[@]}; do
        print_helptext $left_pad_length $module "$(module_docstring $module)"
    done
    echo
    echo "search for commands: sc meta search [term]"
}

# XXX define a high level handle cmd so you can write subcommands for the subcommads
# TODO: this actually needs to wrap this whole base script or else the modules list
# will be wrong for sub-subcommands. We'll need an alternate way to print the usage
# text though (don't think you can define usage multiple times, and idk if you can
# even define a function in a function)
__handle_cmd() {
    # prefixing with _ to prevent overwriting real commands (the side effects
    # won't persist, but it can occasionally screw you up when writing modules)
    # do a search for _\$; should be isolated to the case block for the moment
    cmd=$1
    case $cmd in
        ''|h|-h|help|--help)
            usage
            ;;
        *)
            shift
            if [ $# -eq 0 ]; then
                module_function_usage $cmd
            elif ! [ -z $1 ]; then
                subcmd=$1
                shift
                full_cmd=_${cmd}_$subcmd
                if ! [ "$(type -t $full_cmd)" = function ]; then
                    __error $cmd $subcmd not found
                    exit 1
                else
                    ${full_cmd} "$@"
                fi
            else
                if ! [ "$(type -t _${cmd})" = function ]; then
                    __error $cmd not found
                    exit 1
                else
                    # hack: replace _subcmd with just subcmd (only once)
                    _${cmd} | sed 's/ _/ /'
                fi
            fi
            ;;
    esac
}

__handle_cmd "$@"
