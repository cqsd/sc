#!/bin/bash
# bash hax
# rui <rui@uwu.zone>

# Every file in ./modules/ gets sourced. Each file is a "module" That means
# everything's gonna be in this one top level namespace That means submodules
# can't easily import shit
#
# Every module should prefix all functions with an underscore, the module name,
# and an underscore. So a hello command in the example module would be defined
# as _example_hello()
#
# Every module should define a function named the module name. So the dns
# module defines a dns function. This is called as the subcommand help, so it
# should just echo usage info.
#
# Every module can optionally define a short help function,
# ${module}_short_help, which is called to generate the one-line usage hint in
# the top level usage text. Run this script with no arguments to see what I
# mean.
#
# ***If you can think of a good non-ridiculous way to namespace the functions,
# please let me know.***

set -eo pipefail  # unsure if this is a good idea, but hasn't been annoying yet

__success() { echo -e "\033[32m[+] $@\033[0m"; }  # [+] green
__info()    { echo -e "\033[34m[+] $@\033[0m"; }  # [+] blue
__warn()    { echo -e "\033[33m[-] $@\033[0m"; }  # [-] yellow
__error()   { echo -e "\033[31m[!] $@\033[0m"; }  # [!] red

__remove_json_artifacts() { tr -d '[]",'; }

__BASEDIR=$(dirname "$(readlink "$0")")
__CONFIG_DIR=$__BASEDIR/config
__BIN_DIR=$__BASEDIR/bin

__EDITOR=${EDITOR:-vi}

MODULES=()
for file in ${__BASEDIR}/modules/*; do
    MODULE=$(basename $file)
    case $MODULE in
        _*)
            # skip anything that has a _ at the start of its filename
            continue
            ;;
        *)
            # "load" the module
            source $file
            # Every module should define a function with a name == the file
            # name. Additionally, each one can have a _${filename}_help()
            # function which will get displayed in top-level help.
            # It'll get called as help.
            MODULES+=($MODULE)
    esac
done

# format the subcommands right-justified with 2 spaces indentation for the
# whole list
MODULE_MAX_LENGTH=-1
for module in ${MODULES[@]}; do
    # ${#var} => str length of ${var}
    if [ ${#module} -gt $MODULE_MAX_LENGTH ]; then
        MODULE_MAX_LENGTH=${#module}
    fi
done
MODULE_FORMAT_LENGTH=$((MODULE_MAX_LENGTH + 2))  # 2 space left indent

usage() {
    echo "usage: $(basename $0) <category> [command]"
    echo
    echo "available categories are:"
    for module in ${MODULES[@]}; do
        # TODO these should just be vars set per module, not functions
        # why the fuck are they functions
        #
        # also this would be really useful to refactor and use to generate the
        # help for each subcommand programmatically
        short_help_cmd=_${module}_short_help
        short_help_text=$(${short_help_cmd} 2>/dev/null || echo "help not found")
        printf "%${MODULE_FORMAT_LENGTH}s - %s\n" $module "$short_help_text"
    done
    echo
    echo "search for commands: sc meta search [term]"
}

# XXX define a high level handle cmd so you can write subcommands for the subcommads
# TODO: this actually needs to wrap this whole base script or else the modules list
# will be wrong for sub-subcommands. We'll need an alternate way to print the usage
# text though (don't think you can define usage multiple times, and idk if you can
# even define a function in a function)
__handle_cmd() {
    # prefixing with _ to prevent overwriting real commands (the side effects
    # won't persist, but it can occasionally screw you up when writing modules)
    # do a search for _\$; should be isolated to the case block for the moment
    cmd=$1
    case $cmd in
        ''|h|-h|help|--help)
            usage
            ;;
        *)
            shift
            if ! [ -z $1 ]; then
                subcmd=$1
                shift
                full_cmd=_${cmd}_$subcmd
                if ! [ "$(type -t $full_cmd)" = function ]; then
                    __error $cmd $subcmd not found
                    exit 1
                else
                    # ${full_cmd} $@
                    # __info '$@' is getting quoted rn, which might cause weirdness
                    ${full_cmd} "$@"
                fi
            else
                if ! [ "$(type -t _${cmd})" = function ]; then
                    __error $cmd not found
                    exit 1
                else
                    # hack: replace _subcmd with just subcmd (only once)
                    _${cmd} | sed 's/ _/ /'
                fi
            fi
            ;;
    esac
}

__handle_cmd "$@"
