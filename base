#!/bin/bash
# bash hax
#
# Every file in ./modules/ gets sourced. Each file is a "module" That means
# everything's gonna be in this one top level namespace That means submodules
# can't easily import shit
#
# Every module should prefix all functions with an underscore, the module name,
# and an underscore. So a hello command in the example module would be defined
# as _example_hello()
#
# Open any module to see how helptext is defined.

set -eo pipefail

__sc_success() { echo -e "\033[32m[+] $@\033[0m"; }  # [+] green
__sc_info()    { echo -e "\033[34m[+] $@\033[0m"; }  # [+] blue
__sc_warn()    { echo -e "\033[33m[-] $@\033[0m"; }  # [-] yellow
__sc_error()   { echo -e "\033[31m[!] $@\033[0m"; }  # [!] red

__sc_remove_json_artifacts() { tr -d '[]",'; }

__sc_requires() {
    for cmd in "$@"; do
        if ! command -v $cmd &>/dev/null; then
            echo "this command requires $cmd. please install $cmd"
            exit 1
        fi
    done
}

__sc_requires_one_of() {
    for cmd in "$@"; do
        command -v $cmd &>/dev/null && echo $cmd && return
    done
    echo "this command requires one of $@" >&2
    exit 1
}

__sc_BASEDIR=$(dirname "$(readlink "$0")")
__sc_CONFIG_DIR=$__sc_BASEDIR/config
__sc_BIN_DIR=$__sc_BASEDIR/bin
__sc_DATA_DIR=$__sc_BASEDIR/data

__sc_EDITOR=${EDITOR:-vi}

# skip anything that has a _ at the start of its filename (these are "ignored")
__sc_MODULES=($(echo ${__sc_BASEDIR}/modules/* | xargs -n1 basename | grep -v '^_'))

# return the length of the longest arg
__sc_max_length() {
    MAX_LENGTH=-1
    for s in $@; do
        # ${#var} => str length of ${var}
        if [ ${#s} -gt $MAX_LENGTH ]; then
            MAX_LENGTH=${#s}
        fi
    done
    echo $((MAX_LENGTH))  # dont think the math mode is necessary idc
}

__sc_print_helptext() {
    left_pad_length=$1
    name=$2
    helptext=$3
    printf "  %-${left_pad_length}s - %s\n" $name "${helptext:-no help found}"
}

# grep for top level docstring in a module
__sc_module_docstring() {
    module=$1
    {
        grep -o '^### .*$' $__sc_BASEDIR/modules/$module \
            | sed -e 's/^###//g' \
                  -e 's/^ *//g'
    } || true
}

# grep for "public" function definitions in a module (includes docstrings)
__sc_function_definitions() {
    module=$1
    grep -hior -e "^_${module}_.*().*$" ${__sc_BASEDIR}/modules/$module
}

__sc_function_name_from_definition() {
    grep -v '^__sc_' \
        | sed -e 's/_/ /g' \
              -e 's/ *{.*//g' \
              -e 's/^ *//g' \
              -e 's/()//g' \
        | cut -d' ' -f2-
}

__sc_function_names() {
    __sc_function_definitions $1 | __sc_function_name_from_definition
}

# ngl this is pretty fuckin bad
__sc_function_docstring_from_definition() {
    {
        grep -o '### .*$' \
            | sed -e 's/^###//g' \
                  -e 's/^ *//g'
    } || true # for when grep finds nothing
}

# print function docstrings in a module. this relies on you (me) always
# defining functions a certain way. there's already a lot of that in this
# project, so I'll tolerate it, but it's obviously not great...
__sc_module_function_usage() {
    module=$1
    echo "usage: $module [command]"
    echo
    echo "available commands are:"
    # doing the same grep a bunch of times to keep things simple
    left_pad_length=$(__sc_max_length $(__sc_function_names $module))
    IFS=$'\n'
    for definition in $(__sc_function_definitions $module); do
        name=$(echo $definition | __sc_function_name_from_definition)
        docstring=$(echo $definition | __sc_function_docstring_from_definition)
        __sc_print_helptext $left_pad_length "$name" "$docstring"
    done
    unset IFS
}

__sc_usage() {
    echo "usage: $(basename $0) <module> [command]"
    echo
    echo "available modules are:"
    left_pad_length=$(__sc_max_length ${__sc_MODULES[@]})
    for module in ${__sc_MODULES[@]}; do
        __sc_print_helptext $left_pad_length $module "$(__sc_module_docstring $module)"
    done
    echo
    echo 'search for commands: meta search <term>'
}

__sc_handle_cmd() {
    module=$1; shift || true  # shift errors if no args left
    case $module in
        ''|h|-h|help|--help)
            __sc_usage
            ;;
        *)
            # "load" the "module" if it exists
            module_path=$__sc_BASEDIR/modules/$module
            if [ -f $module_path ]; then
                # print module usage if there's no command
                if [ $# -eq 0 ]; then
                    __sc_module_function_usage $module
                    exit
                fi
                source $module_path
                cmd=$1; shift
                full_cmd=_${module}_$cmd
                if ! [ "$(type -t $full_cmd)" = function ]; then
                    __sc_error $module $cmd not found
                    exit 1
                else
                    ${full_cmd} "$@"
                fi
            else
                __sc_error $module not found
                exit 1
            fi
            ;;
    esac
}

__sc_handle_cmd "$@"
