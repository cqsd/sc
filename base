#!/bin/bash
# bash hax
# rui <rui@uwu.zone>

# Every file in ./modules/ gets sourced. Each file is a "module"
# That means everything's gonna be in this one top level namespace
# That means submodules can't easily import shit
#
# Every module should prefix all functions
# with the module name and an underscore.
# 
# Every module should define a function named the module name. So the
# dns module defines a dns function. This is called as the subcommand
# help, so it should just echo usage info.
#
# Every module can optionally define a short help function,
# ${module}_short_help, which is called to generate the one-line
# usage hint in the top level usage text. Run this script with no
# arguments to see what I mean.
#
# If you can think of a good non-ridiculous way to namespace the
# functions, please let me know.

__success() { echo -e "\033[32m[+]\033[0m $@"; }  # green [+]
__info()    { echo -e "\033[34m[+]\033[0m $@"; }  # green [+]
__warn()    { echo -e "\033[33m[-]\033[0m $@"; }  # green [+]
__error()   { echo -e "\033[31m[!]\033[0m $@"; }  # red   [!]

BASEDIR=$(dirname "$(readlink "$0")")

MODULES=()
for file in ${BASEDIR}/modules/*; do
    MODULE=$(basename $file)
    case $MODULE in
        _*)
            # skip anything that has a _ at the start of its filename
            continue
            ;;
        *)
            # "load" the module
            source $file
            # Every module should define a function with a name == the file name
            # Additionally, every one can have a ${filename}_HELP_TEXT function which
            # will get displayed in top-level help
            # It'll get called as help.
            MODULES+=($MODULE)
    esac
done

# format the subcommands right-justified with 2 spaces indentation for the
# whole list
MODULE_MAX_LENGTH=-1
for module in ${MODULES[@]}; do
    # ${#var} => str length of ${var}
    if [ ${#module} -gt $MODULE_MAX_LENGTH ]; then
        MODULE_MAX_LENGTH=${#module}
    fi
done
MODULE_FORMAT_LENGTH=$((MODULE_MAX_LENGTH + 2))

usage() {
    echo "usage: $(basename $0) command subcommand"
    echo
    echo "available subcommands are:"
    for module in ${MODULES[@]}; do
        short_help_cmd=_${module}_short_help
        short_help_text=$(${short_help_cmd} 2>/dev/null || echo "help not found")
        printf "%${MODULE_FORMAT_LENGTH}s - %s\n" $module "$short_help_text"
    done
}

cmd=$1
# prefixing with _ to prevent overwriting real commands (the side effects
# won't persist, but it can occasionally screw you up when writing modules)
# do a search for _\$; should be isolated to the case block below for the
# moment
case $cmd in
    ''|h|-h|help|--help)
        usage
        ;;
    *)
        shift
        if ! [ -z $1 ]; then
            subcmd=$1
            shift
            full_cmd=_${cmd}_$subcmd
            if ! [ "$(type -t $full_cmd)" = function ]; then
                __error $cmd $subcmd not found
                exit 1
            else
                ${full_cmd} $*
            fi
        else
            if ! [ "$(type -t _${cmd})" = function ]; then
                __error $cmd not found
                exit 1
            else
                # hack: replace _subcmd with just subcmd (only once)
                _${cmd} | sed 's/ _/ /'
            fi
        fi
        ;;
esac
